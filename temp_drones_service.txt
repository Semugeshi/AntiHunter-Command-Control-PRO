import { forwardRef, Inject, Injectable, Logger, OnModuleDestroy, OnModuleInit } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import type { Drone, Site } from '@prisma/client';
import { DroneStatus } from '@prisma/client';
import { BehaviorSubject, Observable, Subject } from 'rxjs';

import { DroneDiff, DroneSnapshot } from './drones.types';
import { PrismaService } from '../prisma/prisma.service';
import { CommandCenterGateway } from '../ws/command-center.gateway';
import { FaaRegistryService } from '../faa/faa.service';
import type { FaaAircraftSummary } from '../faa/faa.types';

@Injectable()
export class DronesService implements OnModuleInit, OnModuleDestroy {
  private readonly logger = new Logger(DronesService.name);
  private readonly localSiteId: string;
  private readonly drones = new Map<string, DroneSnapshot>();
  private readonly snapshot$ = new BehaviorSubject<DroneSnapshot[]>([]);
  private readonly diff$ = new Subject<DroneDiff>();
  private readonly faaLookupCache = new Map<string, { summary: FaaAircraftSummary | null; lastAttempt: number }>();
  private readonly faaLookupCooldownMs: number;

  constructor(
    private readonly prisma: PrismaService,
    private readonly configService: ConfigService,
    private readonly faaRegistry: FaaRegistryService,
    @Inject(forwardRef(() => CommandCenterGateway))
    private readonly gateway: CommandCenterGateway,
  ) {
    this.localSiteId = configService.get<string>('site.id', 'default');
    const cooldownMinutes =
      configService.get<number>('faa.onlineLookupCooldownMinutes', 10) ?? 10;
    this.faaLookupCooldownMs = Math.max(1, cooldownMinutes) * 60 * 1000;
  }

  async onModuleInit(): Promise<void> {
    const records = await this.prisma.drone.findMany({
      include: {
        site: true,
      },
      orderBy: { updatedAt: 'desc' },
      take: 500,
    });

    for (const record of records) {
      const snapshot = this.mapEntity(record);
      await this.attachFaaMetadata(snapshot);
      this.drones.set(snapshot.id, snapshot);
    }

    this.emitSnapshot();
  }

  onModuleDestroy(): void {
    this.snapshot$.complete();
    this.diff$.complete();
  }

  getSnapshot(): DroneSnapshot[] {
    return Array.from(this.drones.values());
  }

  getSnapshotById(id: string): DroneSnapshot | undefined {
    return this.drones.get(id);
  }

  getSnapshotStream(): Observable<DroneSnapshot[]> {
    return this.snapshot$.asObservable();
  }

  getDiffStream(): Observable<DroneDiff> {
    return this.diff$.asObservable();
  }

  async upsert(snapshot: DroneSnapshot): Promise<DroneSnapshot> {
    const normalized: DroneSnapshot = {
      ...snapshot,
      siteId: snapshot.siteId ?? this.localSiteId,
      originSiteId: snapshot.originSiteId ?? snapshot.siteId ?? this.localSiteId,
      lastSeen: snapshot.lastSeen ?? new Date(),
    };

    try {
      await this.ensureSiteRecord(
        normalized.siteId,
        normalized.siteName ?? null,
        normalized.siteColor ?? null,
        normalized.siteCountry ?? null,
        normalized.siteCity ?? null,
      );

      const record = await this.prisma.drone.upsert({
        where: { id: normalized.id },
        create: {
          id: normalized.id,
          droneId: normalized.droneId ?? null,
          mac: normalized.mac ?? null,
          nodeId: normalized.nodeId ?? null,
          siteId: normalized.siteId ?? null,
          originSiteId: normalized.originSiteId ?? normalized.siteId ?? null,
          lat: normalized.lat,
          lon: normalized.lon,
          altitude: normalized.altitude ?? null,
          speed: normalized.speed ?? null,
          operatorLat: normalized.operatorLat ?? null,
          operatorLon: normalized.operatorLon ?? null,
          rssi: normalized.rssi != null ? Math.round(normalized.rssi) : null,
          lastSeen: normalized.lastSeen,
          status: normalized.status ?? DroneStatus.UNKNOWN,
        },
        update: {
          droneId: normalized.droneId ?? null,
          mac: normalized.mac ?? null,
          nodeId: normalized.nodeId ?? null,
          siteId: normalized.siteId ?? null,
          originSiteId: normalized.originSiteId ?? undefined,
          lat: normalized.lat,
          lon: normalized.lon,
          altitude: normalized.altitude ?? null,
          speed: normalized.speed ?? null,
          operatorLat: normalized.operatorLat ?? null,
          operatorLon: normalized.operatorLon ?? null,
          rssi: normalized.rssi != null ? Math.round(normalized.rssi) : null,
          lastSeen: normalized.lastSeen,
          status: normalized.status ?? undefined,
        },
        include: { site: true },
      });

      const mapped = this.mapEntity(record);
      await this.attachFaaMetadata(mapped);
      this.drones.set(mapped.id, mapped);
      this.emitSnapshot();
      this.diff$.next({ type: 'upsert', drone: mapped });
      return mapped;
    } catch (error) {
      this.logger.error(
        `Failed to upsert drone ${snapshot.id}: ${error instanceof Error ? error.message : error}`,
      );
      throw error;
    }
  }

  async updateStatus(id: string, status: DroneStatus): Promise<DroneSnapshot> {
    const record = await this.prisma.drone.update({
      where: { id },
      data: { status },
      include: { site: true },
    });
    const mapped = this.mapEntity(record);
    await this.attachFaaMetadata(mapped);
    this.drones.set(mapped.id, mapped);
    this.emitSnapshot();
    this.diff$.next({ type: 'upsert', drone: mapped });
    return mapped;
  }

  async remove(id: string): Promise<void> {
    const existing = this.drones.get(id);
    if (!existing) {
      return;
    }
    await this.prisma.drone.delete({ where: { id } }).catch((error) => {
      this.logger.warn(
        `Failed to delete drone ${id}: ${error instanceof Error ? error.message : error}`,
      );
    });
    this.drones.delete(id);
    this.emitSnapshot();
    this.diff$.next({ type: 'delete', drone: existing });
    this.emitRemovalEvent(existing);
  }

  async clearAll(): Promise<void> {
    if (this.drones.size === 0) {
      await this.prisma.drone.deleteMany().catch(() => undefined);
      return;
    }
    const existing = Array.from(this.drones.values());
    await this.prisma.drone.deleteMany();
    this.drones.clear();
    this.faaLookupCache.clear();
    this.emitSnapshot();
    existing.forEach((drone) => {
      this.diff$.next({ type: 'delete', drone });
      this.emitRemovalEvent(drone);
    });
  }

  private emitSnapshot(): void {
    this.snapshot$.next(
      Array.from(this.drones.values()).sort((a, b) => b.lastSeen.getTime() - a.lastSeen.getTime()),
    );
  }

  private mapEntity(drone: Drone & { site?: Site | null }): DroneSnapshot {
    const existing = this.drones.get(drone.id);
    return {
      id: drone.id,
      droneId: drone.droneId ?? null,
      mac: drone.mac ?? null,
      nodeId: drone.nodeId ?? null,
      siteId: drone.siteId ?? null,
      originSiteId: drone.originSiteId ?? null,
      siteName: drone.site?.name ?? null,
      siteColor: drone.site?.color ?? null,
      siteCountry: drone.site?.country ?? null,
      siteCity: drone.site?.city ?? null,
      lat: drone.lat,
      lon: drone.lon,
      altitude: drone.altitude ?? null,
      speed: drone.speed ?? null,
      operatorLat: drone.operatorLat ?? null,
      operatorLon: drone.operatorLon ?? null,
      rssi: drone.rssi ?? null,
      status: drone.status ?? DroneStatus.UNKNOWN,
      lastSeen: drone.lastSeen,
      ts: drone.updatedAt,
      faa: existing?.faa ?? null,
    };
  }

  private async attachFaaMetadata(snapshot: DroneSnapshot): Promise<void> {
    if (!snapshot.droneId && !snapshot.mac) {
      snapshot.faa = null;
      return;
    }
    if (snapshot.faa) {
      return;
    }
    const cacheKey = (snapshot.droneId ?? snapshot.mac ?? snapshot.id).toUpperCase();
    const cached = this.faaLookupCache.get(cacheKey);
    const now = Date.now();
    if (cached && now - cached.lastAttempt < this.faaLookupCooldownMs) {
      snapshot.faa = cached.summary;
      return;
    }
    try {
      const summary = await this.faaRegistry.lookupAircraft(snapshot.droneId, snapshot.mac);
      snapshot.faa = summary ?? null;
      this.faaLookupCache.set(cacheKey, { summary: snapshot.faa, lastAttempt: now });
    } catch (error) {
      this.logger.debug(
        `FAA lookup failed for drone ${snapshot.id}: ${error instanceof Error ? error.message : error}`,
      );
      snapshot.faa = null;
      this.faaLookupCache.set(cacheKey, { summary: null, lastAttempt: now });
    }
  }

  private async ensureSiteRecord(
    siteId?: string | null,
    name?: string | null,
    color?: string | null,
    country?: string | null,
    city?: string | null,
  ): Promise<void> {
    if (!siteId) {
      return;
    }

    try {
      await this.prisma.site.upsert({
        where: { id: siteId },
        update: {
          name: name ?? undefined,
          color: color ?? undefined,
          country: country ?? undefined,
          city: city ?? undefined,
        },
        create: {
          id: siteId,
          name: name ?? siteId,
          color: color ?? '#0ea5e9',
          country: country ?? undefined,
          city: city ?? undefined,
        },
      });
    } catch (error) {
      this.logger.debug(
        `Failed to ensure site record for ${siteId}: ${error instanceof Error ? error.message : error}`,
      );
    }
  }

  private emitRemovalEvent(drone: DroneSnapshot): void {
    try {
      this.gateway.emitEvent({
        type: 'drone.remove',
        droneId: drone.droneId ?? drone.id,
        id: drone.id,
        siteId: drone.siteId ?? undefined,
        nodeId: drone.nodeId ?? undefined,
      });
    } catch (error) {
      this.logger.debug(
        `Failed to emit drone removal event for ${drone.id}: ${error instanceof Error ? error.message : error}`,
      );
    }
  }
}

